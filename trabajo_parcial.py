# -*- coding: utf-8 -*-
"""Trabajo Parcial.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1huMwBuX0FTASA7biD4bvwxvv9wmiyDCc

#  Pre-Procesamiento de los datos

#2 Carga de Librerias del proyecto
"""

# Commented out IPython magic to ensure Python compatibility.
# Importar paquetes
import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt

st.title("Mi Proyecto desde Colab 🚀")
# %matplotlib inline

#Automcompletar rápido
# %config IPCompleter.greedy=True
#Desactivar la notación científica
pd.options.display.float_format = '{:.2f}'.format


"""## 2.1- Etapa de combinación de datos
En esta etapa combinaremos los DataFrames en uno solo con el propósito de facilitar la limpieza de datos y realizar un análisis preciso.
"""

"""Muestra las 5 primeras filas"""


"""Muestre las 6 ultimas filas"""

df_netflix.tail(6)

"""## 2.2- Etapa de calidad y limpieza de datos
En esta etapa, nos enfocamos en mejorar la integridad de los datos mediante la detección y corrección de errores, eliminación de duplicados y estandarización de formatos, garantizando así su precisión y fiabilidad para el análisis.

###2.2.1 Correccion de cabeceras o headers
"""

columnas_renombrar={'Gender':'Genero','Age':'Edad','title':'Titulo','country':'Pais'}
df_netflix.rename(columns =columnas_renombrar, inplace = True)

df_netflix.head(3)

"""### 2.2.2 Exploración inicial (Overview Data)

"""

df_netflix.shape

"""Consultar la estructura del dataset"""

df_netflix.info();

"""###2.2.3Data Type Mismatch(Tipos de datos en la estructura)

Listado de columnas y su tipo de dato
"""

df_netflix.head(3)

df_netflix.dtypes

"""Castee los tipos de datos correctos"""

columnas_castear = {'Genero':'category','Titulo':'category','Edad':'category','Pais':'category'}
df_netflix=df_netflix.astype(columnas_castear)

df_netflix.head(3)

"""Listar los tipos de datos y revise si los tipos de datos son correctos

"""

df_netflix.dtypes

df_netflix.drop(columns=['director','show_id', 'cast', 'description', 'Rational', 'date_added_month','date_added_day'], inplace=True)

"""### 2.2.4 Valores únicos (hay constantes?)

"""

df_netflix.nunique().sort_values(ascending=True)

df_netflix.nunique().sort_values(ascending=True)

"""### 2.2.5 Duplicados

Liste la forma del dataframe
"""

df_netflix.shape

"""Metodo duplicates del dataframe para evaluar nulos"""

df_netflix.duplicated().sum()

"""Identificar ñas filas duplicadas"""

df_netflix[df_netflix.duplicated()]

"""Eliminar las filas duplicatas"""

# Eliminar filas duplicadas para evitar que los datos repetidos influyan en el análisis
df_netflix.drop_duplicates(inplace=True)
df_netflix.shape

"""### 2.2.6 Missing Data

####Filas

Liste la forma del dataframe
"""

print(df_netflix.shape)

"""Evaluar la cantidada de COLUMNAS que cada FILA tiene"""

df_netflix.isnull()

"""sumar cuantos true hay en las columnas por cada fila"""

df_netflix.isnull().sum(axis=1).sort_values(ascending=False)

"""calcular el porcentaje de columnas en NULO, usando shape"""

(df_netflix.isnull().sum(axis=1)/df_netflix.shape[1]*100).sort_values(ascending=False)

"""Evaluar eliminar filas con una cantodad determinada de nulos"""

df_netflix.dropna(thresh=9, inplace=True)
print(df_netflix.shape)

"""####Columas

#####columna categorica

Extraer las variables categoricas o no numericas
"""

df_cat=df_netflix.select_dtypes(exclude='number').copy()

df_cat

"""ver la cantidad de nulos existentes por cada columna (isnul())"""

df_cat.isnull().sum().sort_values(ascending=False)

"""Cuanto es en porcentaje la cantidad de nulos por cada columna"""

df_cat.isnull().sum().sort_values(ascending=False)*100/len(df_cat)

"""Eliminar la variable si la cantidad filas es excesiva con nulos"""

#CAMBIO PAIS POR Languages

df_cat.drop(columns ='Languages', inplace=True)
df_cat.isnull().sum().sort_values(ascending=False)*100/len(df_cat)

"""Imputacion con avalor definido"""

print('Variable "Pais"\n')
print(df_cat['Pais'].value_counts())   #cambie por pais porque languages ya fue elimnada
print('\ntotal de nulos', df_cat ['Pais'].isnull().sum())
print('total de filas',df_cat['Pais'].count())

print('Cantidad de datos nulos por columna:')
print(df_netflix.isnull().sum())

"""GRAFICA GENERO Y TIPO

"""

#REEMPLAZAR PARA SOLUCIONAR ERRORES PASADOS
# Reemplazar valores no deseados (como cadenas vacías o valores NaN) en 'type'
df_cat['type'] = df_cat['type'].replace(['', 'nan', None], 'Unknown')

# Convertir la columna 'type' a tipo categoría
df_cat['type'] = df_cat['type'].astype('category')

# Reemplazar los valores de la columna 'type' por las etiquetas correspondientes
df_cat['type'] = df_cat['type'].replace({1: 'Pelicula', 2: 'Serie'})

# Limpiar los valores no deseados, reemplazando 'Unknown' y 'William Wyler' por valores apropiados
df_cat['type'] = df_cat['type'].replace(['Unknown', 'William Wyler'], 'Other')

# Ahora realizar la gráfica
df_cat.groupby(['Genero'], observed=False)['type'].value_counts().unstack().plot(kind='bar')

"""Imputar las filas nulas de la variable "Genero" con valor de "Female"
"""

valor_imputar = 'Female'
columnas_imputar = ['Genero']
df_cat[columnas_imputar] = df_cat[columnas_imputar].fillna(valor_imputar)

df_cat.groupby(['Genero'])['type'].value_counts().unstack().plot(kind='bar');

"""Imputar por la moda"""

print(df_cat['Genero'].mode())
df_cat['Genero'].mode()[0]

"""Imputar las filas nulas de las variables "Genero", "Pais" y "Temporada" por el valor de su respectiva moda"""

valor_moda_Genero           = df_cat['Genero'].mode()[0]
valor_moda_Pais        = df_cat['Pais'].mode()[0]

df_cat['Genero']                = df_cat['Genero'].fillna(valor_moda_Genero)
df_cat['Pais']             = df_cat['Pais'].fillna(valor_moda_Pais)

"""Listado resultado de las variables categoricas si existen algun NULO"""

df_cat.isna().sum().sort_values(ascending=False)

"""#####Columna Numerica"""

df_num=df_netflix.select_dtypes(include='number').copy()

"""Evaluar cantidad de nulos"""

print(df_num.shape)
df_num.isna().sum().sort_values(ascending=False)

#Analizamos con estadísticos básicos como se comporta el promedio y la media
df_num.describe().T

"""imputamos por la mediana"""

valor_mediana_premium  = df_num['Cost Per Month - Premium ($)'].median()
valor_mediana_standar    = df_num['Cost Per Month - Standard ($)'].median()

df_num['Cost Per Month - Premium ($)']  = df_num['Cost Per Month - Premium ($)'].fillna(valor_mediana_premium)
df_num['Cost Per Month - Standard ($)']    = df_num['Cost Per Month - Standard ($)'].fillna(valor_mediana_standar)

"""Listado resultado de las variables numericas si existen algun NULO"""

df_num.isna().sum().sort_values(ascending=False)

"""### 2.2.7 Outliers (atípicos)

### Columnas Categoricas

* Estrategias categóricas
   * Imputar por un valor establecido
   * Imputar por la moda
"""

df_netflix.info();

"""###Analisis de Outliers para la variable duration"""

# Asegurarse de que 'duration (min)' sea numérica
df_netflix['duration (min)'] = pd.to_numeric(df_netflix['duration (min)'], errors='coerce')

# Boxplot para visualizar outliers
plt.figure(figsize=(6, 4))
sns.boxplot(y=df_netflix['duration (min)'])
plt.title('Análisis de Outliers: Duración (min)')
plt.ylabel('Duración en minutos')
plt.grid(True)
plt.show()

# Cálculo de IQR
Q1 = df_netflix['duration (min)'].quantile(0.25)
Q3 = df_netflix['duration (min)'].quantile(0.75)
IQR = Q3 - Q1
lim_inf = Q1 - 1.5 * IQR
lim_sup = Q3 + 1.5 * IQR

# Detección de outliers
outliers = df_netflix[(df_netflix['duration (min)'] < lim_inf) | (df_netflix['duration (min)'] > lim_sup)]

print(f"Cantidad de outliers en 'duration (min)': {len(outliers)}")
print(f"Porcentaje: {len(outliers) / len(df_netflix) * 100:.2f}%")

"""###Analisis de Outliers para la variable Cost Per Month"""

# Asegurarse de que 'Cost Per Month - Premium ($)' sea numérica
df_netflix['Cost Per Month - Premium ($)'] = pd.to_numeric(df_netflix['Cost Per Month - Premium ($)'], errors='coerce')

# Boxplot para visualizar outliers en 'Cost Per Month - Premium ($)'
plt.figure(figsize=(6, 4))
sns.boxplot(y=df_netflix['Cost Per Month - Premium ($)'])
plt.title('Análisis de Outliers: Cost Per Month - Premium ($)')
plt.ylabel('Costo por mes (Premium) en dólares')
plt.grid(True)
plt.show()

# Cálculo de IQR para detectar outliers
Q1_premium = df_netflix['Cost Per Month - Premium ($)'].quantile(0.25)
Q3_premium = df_netflix['Cost Per Month - Premium ($)'].quantile(0.75)
IQR_premium = Q3_premium - Q1_premium
lim_inf_premium = Q1_premium - 1.5 * IQR_premium
lim_sup_premium = Q3_premium + 1.5 * IQR_premium

# Detección de outliers
outliers_premium = df_netflix[(df_netflix['Cost Per Month - Premium ($)'] < lim_inf_premium) | (df_netflix['Cost Per Month - Premium ($)'] > lim_sup_premium)]

# Mostrar la cantidad de outliers y su porcentaje
outliers_premium_count = len(outliers_premium)
outliers_premium_percentage = (outliers_premium_count / len(df_netflix)) * 100


# Detección de outliers

print(f"Cantidad de outliers: {outliers_premium_count}")
print(f"Porcentaje: {outliers_premium_percentage:.2f}%")

"""###Analisis de Outliers para la variable No. of TV Shows"""

# Asegurarse de que 'No. of TV Shows' sea numérica
df_netflix['No. of TV Shows'] = pd.to_numeric(df_netflix['No. of TV Shows'], errors='coerce')

# Boxplot para visualizar outliers en 'No. of TV Shows'
plt.figure(figsize=(6, 4))
sns.boxplot(y=df_netflix['No. of TV Shows'])
plt.title('Análisis de Outliers: No. of TV Shows')
plt.ylabel('Número de Programas de Televisión')
plt.grid(True)
plt.show()

# Cálculo de IQR para detectar outliers en 'No. of TV Shows'
Q1_tv_shows = df_netflix['No. of TV Shows'].quantile(0.25)
Q3_tv_shows = df_netflix['No. of TV Shows'].quantile(0.75)
IQR_tv_shows = Q3_tv_shows - Q1_tv_shows
lim_inf_tv_shows = Q1_tv_shows - 1.5 * IQR_tv_shows
lim_sup_tv_shows = Q3_tv_shows + 1.5 * IQR_tv_shows

# Detección de outliers
outliers_tv_shows = df_netflix[(df_netflix['No. of TV Shows'] < lim_inf_tv_shows) | (df_netflix['No. of TV Shows'] > lim_sup_tv_shows)]

# Mostrar la cantidad de outliers y su porcentaje
outliers_tv_shows_count = len(outliers_tv_shows)
outliers_tv_shows_percentage = (outliers_tv_shows_count / len(df_netflix)) * 100

outliers_tv_shows_count, outliers_tv_shows_percentage

"""### CREACION DE NUEVO DATAFRAME LIMPIO"""

df_clean_netflix = df_netflix.copy()

print(df_clean_netflix.columns)

df_clean_netflix.shape

print('Cantidad de datos nulos por columna:')
print(df_clean_netflix.isnull().sum())

df_clean_netflix.head()

"""## 2.3- EDA"""



# Seleccionar columnas numéricas del DataFrame
numeric_columns = df_clean_netflix.select_dtypes(include=['float64', 'int64']).columns

# Calcular el número de filas y columnas para el grid
num_columns = len(numeric_columns)
num_rows = (num_columns // 5) + (num_columns % 5 > 0)  # Redondear hacia arriba si no es exacto

# Crear histograma de todas las variables numéricas
plt.figure(figsize=(15, 10))
for i, col in enumerate(numeric_columns, 1):
    plt.subplot(num_rows, 5, i)  # Ajustar el grid a las filas necesarias y 5 columnas
    sns.histplot(df_clean_netflix[col], kde=True, color='skyblue', bins=20)
    plt.title(f'Distribución de {col}')
    plt.tight_layout()

plt.show()

"""## 3.- Insights

**1. ¿De qué manera influye la variedad de géneros consumidos en la precisión de las recomendaciones personalizadas?**
"""

plt.figure(figsize=(10,6))
sns.boxplot(x='Genre_content', y='Satisfaction_score', data=df_netflix)
plt.title('Influencia del género en la satisfacción de las recomendaciones')
plt.xticks(rotation=90)
plt.show()

"""**2. ¿Cómo impacta la duración del contenido que prefieren los usuarios en la personalización de las recomendaciones?**

"""

plt.figure(figsize=(10,6))
sns.scatterplot(x='duration (min)', y='Satisfaction_score', data=df_netflix)
plt.title('Relación entre duración del contenido y satisfacción')
plt.show()

# Crear un gráfico de barras para visualizar la relación entre la frecuencia y la satisfacción promedio
plt.figure(figsize=(10, 6))
sns.barplot(x='Freq', y='Satisfaction_score', data=df_clean_netflix, palette='Blues_d')

# Añadir títulos y etiquetas
plt.title('Relación entre la Frecuencia de Consumo y la Satisfacción de las Recomendaciones', fontsize=14)
plt.xlabel('Frecuencia de Consumo', fontsize=12)
plt.ylabel('Puntaje Promedio de Satisfacción', fontsize=12)
plt.xticks(rotation=45)
plt.tight_layout()

# Mostrar el gráfico
plt.show()

"""**3. ¿Qué papel juega la frecuencia de consumo de contenido en la mejora continua del algoritmo de recomendación?**"""

plt.figure(figsize=(10,6))
sns.scatterplot(x='Freq', y='Satisfaction_score', data=df_netflix)
plt.title('Frecuencia de consumo y satisfacción del usuario')
plt.show()

"""**4. ¿Cómo influye el género de los usuarios en la efectividad del algoritmo de recomendaciones?**"""

plt.figure(figsize=(10,6))
sns.boxplot(x='Gender', y='Satisfaction_score', data=df_netflix)
plt.title('Efectividad de las recomendaciones según el género del usuario')
plt.show()

# Gráfico de dispersión entre 'Age' y 'Satisfaction_score' con color por 'Gender'
plt.figure(figsize=(8, 6))
sns.scatterplot(x='Age', y='Satisfaction_score', hue='Gender', data=df_clean_netflix, palette='Set2', alpha=0.7)
plt.title('Relación entre Edad y Satisfacción por Género')
plt.xlabel('Edad')
plt.ylabel('Satisfaction Score')
plt.show()

"""**5. ¿De qué manera afectan las calificaciones de los títulos vistos a la precisión de futuras recomendaciones?**"""

plt.figure(figsize=(10,6))
sns.scatterplot(x='imdb_score', y='Satisfaction_score', data=df_netflix)
plt.title('Influencia de las calificaciones en la satisfacción de las recomendaciones')
plt.show()

"""**MODELADO**"""

import pandas as pd
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeRegressor, plot_tree
from sklearn.metrics import mean_squared_error, r2_score

# Cargar la base de datos desde la URL
url = 'https://docs.google.com/spreadsheets/d/12cNZzy0YBlHqwHfhgOeOoyGWJ7FZf0jF/export?format=xlsx&gid=1568855192'
df = pd.read_excel(url)

# Eliminar filas con valores nulos en las columnas seleccionadas
df = df.dropna(subset=['Satisfaction_score', 'Genre_content', 'duration (min)', 'Freq', 'Gender', 'imdb_score'])

# Codificación One-Hot para 'Genre_content' (por género)
df_encoded_genre = pd.get_dummies(df['Genre_content'], prefix='Genre')

# Codificación de 'Gender' con valores 0 y 1
df['Gender'] = df['Gender'].map({'Male': 0, 'Female': 1})

# Variables independientes
X = pd.concat([df_encoded_genre, df[['duration (min)', 'Freq', 'Gender', 'imdb_score']]], axis=1)

# Variable dependiente
y = df['Satisfaction_score']

# Dividir los datos en entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Crear el modelo con parámetros ajustados para mayor claridad
tree_model = DecisionTreeRegressor(random_state=42, max_depth=5 , min_samples_split=20, min_samples_leaf=10)

# Ajustar el modelo a los datos de entrenamiento
tree_model.fit(X_train, y_train)

# Realizar predicciones
y_pred = tree_model.predict(X_test)

# Evaluar el modelo
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

# Mostrar resultados
print(f"R^2: {r2}")
print(f"MSE: {mse}")

# Visualizar el árbol con ajustes para separar mejor los nodos
plt.figure(figsize=(40, 14))  # Aumentar el tamaño de la figura
plot_tree(tree_model, filled=True, feature_names=X.columns, fontsize=10, max_depth=5,
          proportion=False, precision=2, node_ids=True, rounded=True, label='all')  # Reducir profundidad y mejorar visualización
plt.title("Árbol de Decisiones para Satisfaction_score")
plt.show()

"""Predicción del nivel de satisfacción (Satisfaction_score)
El modelo predice una variable numérica continua que representa qué tan satisfecho está un usuario con la plataforma o el contenido.

Análisis de variables influyentes
Permite visualizar mediante un árbol de decisión cómo influyen las variables mencionadas sobre la satisfacción. Esto ayuda a responder preguntas como:

¿Los usuarios prefieren ciertos géneros?

¿Influye la duración del contenido en su satisfacción?

¿Hay diferencias entre géneros (hombres/mujeres) respecto a la satisfacción?

Soporte para la toma de decisiones estratégicas
Netflix o plataformas similares podrían usar estos insights para:

Recomendar contenido más alineado con lo que genera mayor satisfacción.

Detectar perfiles de usuarios con baja satisfacción.

Ajustar su catálogo según patrones de consumo detectados.

Modelo interpretable
A diferencia de modelos más complejos, un árbol de decisión es visual e interpretativo, por lo que es útil para presentar hallazgos a equipos no técnicos (marketing, UX, etc.).


"""
